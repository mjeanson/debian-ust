'\" t
.\"     Title: lttng-ust
.\"    Author: [see the "AUTHORS" section]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 06/12/2017
.\"    Manual: LTTng Manual
.\"    Source: LTTng 2.9.1
.\"  Language: English
.\"
.TH "LTTNG\-UST" "3" "06/12/2017" "LTTng 2\&.9\&.1" "LTTng Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
lttng-ust \- LTTng user space tracing
.SH "SYNOPSIS"
.sp
.nf
\fB#include <lttng/tracepoint\&.h>\fR
.fi
.sp
.nf
#define \fBTRACEPOINT_ENUM\fR(\fIprov_name\fR, \fIenum_name\fR, \fImappings\fR)
#define \fBTRACEPOINT_EVENT\fR(\fIprov_name\fR, \fIt_name\fR, \fIargs\fR, \fIfields\fR)
#define \fBTRACEPOINT_EVENT_CLASS\fR(\fIprov_name\fR, \fIclass_name\fR, \fIargs\fR, \fIfields\fR)
#define \fBTRACEPOINT_EVENT_INSTANCE\fR(\fIprov_name\fR, \fIclass_name\fR, \fIt_name\fR, \fIargs\fR)
#define \fBTRACEPOINT_LOGLEVEL\fR(\fIprov_name\fR, \fIt_name\fR, \fIlevel\fR)
#define \fBctf_array\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_nowrite_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_network\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_network_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_network_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_network_nowrite_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_text\fR(char, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_array_text_nowrite\fR(char, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
#define \fBctf_enum\fR(\fIprov_name\fR, \fIenum_name\fR, \fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
#define \fBctf_enum_nowrite\fR(\fIprov_name\fR, \fIenum_name\fR, \fIint_type\fR, \fIfield_name\fR,
                         \fIexpr\fR)
#define \fBctf_enum_value\fR(\fIlabel\fR, \fIvalue\fR)
#define \fBctf_enum_range\fR(\fIlabel\fR, \fIstart\fR, \fIend\fR)
#define \fBctf_float\fR(\fIfloat_type\fR, \fIfield_name\fR, \fIexpr\fR)
#define \fBctf_float_nowrite\fR(\fIfloat_type\fR, \fIfield_name\fR, \fIexpr\fR)
#define \fBctf_integer\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
#define \fBctf_integer_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
#define \fBctf_integer_network\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
#define \fBctf_integer_network_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
#define \fBctf_integer_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
#define \fBctf_sequence\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR, \fIlen_expr\fR)
#define \fBctf_sequence_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                             \fIlen_expr\fR)
#define \fBctf_sequence_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                         \fIlen_expr\fR)
#define \fBctf_sequence_nowrite_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                                 \fIlen_expr\fR)
#define \fBctf_sequence_network\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                             \fIlen_expr\fR)
#define \fBctf_sequence_network_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR,
                                     \fIlen_type\fR, \fIlen_expr\fR)
#define \fBctf_sequence_network_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                                 \fIlen_expr\fR)
#define \fBctf_sequence_network_nowrite_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR,
                                         \fIlen_type\fR, \fIlen_expr\fR)
#define \fBctf_sequence_text\fR(char, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR, \fIlen_expr\fR)
#define \fBctf_sequence_text_nowrite\fR(char, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                                  \fIlen_expr\fR)
#define \fBctf_string\fR(\fIfield_name\fR, \fIexpr\fR)
#define \fBctf_string_nowrite\fR(\fIfield_name\fR, \fIexpr\fR)
#define \fBdo_tracepoint\fR(\fIprov_name\fR, \fIt_name\fR, \&...)
#define \fBtracepoint\fR(\fIprov_name\fR, \fIt_name\fR, \&...)
#define \fBtracepoint_enabled\fR(\fIprov_name\fR, \fIt_name\fR)
.fi
.sp
Link with \fB-llttng-ust -ldl\fR, following this man page\&.
.SH "DESCRIPTION"
.sp
The \fILinux Trace Toolkit: next generation\fR <http://lttng.org/> is an open source software package used for correlated tracing of the Linux kernel, user applications, and user libraries\&.
.sp
LTTng\-UST is the user space tracing component of the LTTng project\&. It is a port to user space of the low\-overhead tracing capabilities of the LTTng Linux kernel tracer\&. The \fBliblttng-ust\fR library is used to trace user applications and libraries\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This man page is about the \fBliblttng-ust\fR library\&. The LTTng\-UST project also provides Java and Python packages to trace applications written in those languages\&. How to instrument and trace Java and Python applications is documented in the online LTTng documentation <http://lttng.org/docs/>\&.
.sp .5v
.RE
.sp
There are three ways to use \fBliblttng-ust\fR:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Using the
\fBtracef\fR(3)
API, which is similar to
\fBprintf\fR(3)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Using the
\fBtracelog\fR(3)
API, which is
\fBtracef\fR(3)
with a log level parameter\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Defining your own tracepoints\&. See the
\fICreating a tracepoint provider\fR
section below\&.
.RE
.SS "Creating a tracepoint provider"
.sp
Creating a tracepoint provider is the first step of using \fBliblttng-ust\fR\&. The next steps are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIInstrumenting your application with tracepoint() calls\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Building your application with LTTng\-UST support, either
\fIstatically\fR
or
\fIdynamically\fR\&.
.RE
.sp
A \fBtracepoint provider\fR is a compiled object containing the event probes corresponding to your custom tracepoint definitions\&. A tracepoint provider contains the code to get the size of an event and to serialize it, amongst other things\&.
.sp
To create a tracepoint provider, start with the following \fItracepoint provider header\fR template:
.sp
.if n \{\
.RS 4
.\}
.nf
#undef TRACEPOINT_PROVIDER
#define TRACEPOINT_PROVIDER my_provider

#undef TRACEPOINT_INCLUDE
#define TRACEPOINT_INCLUDE "\&./tp\&.h"

#if !defined(_TP_H) || defined(TRACEPOINT_HEADER_MULTI_READ)
#define _TP_H

#include <lttng/tracepoint\&.h>

/*
 * TRACEPOINT_EVENT(), TRACEPOINT_EVENT_CLASS(),
 * TRACEPOINT_EVENT_INSTANCE(), TRACEPOINT_LOGLEVEL(),
 * and `TRACEPOINT_ENUM()` are used here\&.
 */

#endif /* _TP_H */

#include <lttng/tracepoint\-event\&.h>
.fi
.if n \{\
.RE
.\}
.sp
In this template, the tracepoint provider is named \fBmy_provider\fR (\fBTRACEPOINT_PROVIDER\fR definition)\&. The file needs to bear the name of the \fBTRACEPOINT_INCLUDE\fR definition (\fBtp.h\fR in this case)\&. Between \fB#include <lttng/tracepoint.h>\fR and \fB#endif\fR go the invocations of the \fITRACEPOINT_EVENT()\fR, \fITRACEPOINT_EVENT_CLASS()\fR, \fITRACEPOINT_EVENT_INSTANCE()\fR, \fITRACEPOINT_LOGLEVEL()\fR, and \fITRACEPOINT_ENUM()\fR macros\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
You can avoid writing the prologue and epilogue boilerplate in the template file above by using the \fBlttng-gen-tp\fR(1) tool shipped with LTTng\-UST\&.
.sp .5v
.RE
.sp
The tracepoint provider header file needs to be included in a source file which looks like this:
.sp
.if n \{\
.RS 4
.\}
.nf
#define TRACEPOINT_CREATE_PROBES

#include "tp\&.h"
.fi
.if n \{\
.RE
.\}
.sp
Together, those two files (let\(cqs call them \fBtp.h\fR and \fBtp.c\fR) form the tracepoint provider sources, ready to be compiled\&.
.sp
You can create multiple tracepoint providers to be used in a single application, but each one must have its own header file\&.
.sp
The \fITRACEPOINT_EVENT() usage\fR section below shows how to use the \fBTRACEPOINT_EVENT()\fR macro to define the actual tracepoints in the tracepoint provider header file\&.
.sp
See the \fIEXAMPLE\fR section below for a complete example\&.
.SS "TRACEPOINT_EVENT() usage"
.sp
The \fBTRACEPOINT_EVENT()\fR macro is used in a template provider header file (see the \fICreating a tracepoint provider\fR section above) to define LTTng\-UST tracepoints\&.
.sp
The \fBTRACEPOINT_EVENT()\fR usage template is as follows:
.sp
.if n \{\
.RS 4
.\}
.nf
TRACEPOINT_EVENT(
    /* Tracepoint provider name */
    my_provider,

    /* Tracepoint/event name */
    my_tracepoint,

    /* List of tracepoint arguments (input) */
    TP_ARGS(
        \&.\&.\&.
    ),

    /* List of fields of eventual event (output) */
    TP_FIELDS(
        \&.\&.\&.
    )
)
.fi
.if n \{\
.RE
.\}
.sp
The \fBTP_ARGS()\fR macro contains the input arguments of the tracepoint\&. Those arguments can be used in the argument expressions of the output fields defined in \fBTP_FIELDS()\fR\&.
.sp
The format of the \fBTP_ARGS()\fR parameters is: C type, then argument name; repeat as needed, up to ten times\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
TP_ARGS(
    int, my_int,
    const char *, my_string,
    FILE *, my_file,
    double, my_float,
    struct my_data *, my_data
)
.fi
.if n \{\
.RE
.\}
.sp
The \fBTP_FIELDS()\fR macro contains the output fields of the tracepoint, that is, the actual data that can be recorded in the payload of an event emitted by this tracepoint\&.
.sp
The \fBTP_FIELDS()\fR macro contains a list of \fBctf_*()\fR macros NOT separated by commas\&. The available macros are documented in the \fIAvailable ctf_*() field type macros\fR section below\&.
.SS "Available ctf_*() field type macros"
.sp
This section documents the available \fBctf_*()\fR macros that can be inserted in the \fBTP_FIELDS()\fR macro of the \fITRACEPOINT_EVENT() macro\fR\&.
.sp
Standard integer, displayed in base 10:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_integer\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
\fBctf_integer_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
.fi
.if n \{\
.RE
.\}
.sp
Standard integer, displayed in base 16:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_integer_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
.fi
.if n \{\
.RE
.\}
.sp
Integer in network byte order (big endian), displayed in base 10:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_integer_network\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
.fi
.if n \{\
.RE
.\}
.sp
Integer in network byte order, displayed in base 16:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_integer_network_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
.fi
.if n \{\
.RE
.\}
.sp
Floating point number:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_float\fR(\fIfloat_type\fR, \fIfield_name\fR, \fIexpr\fR)
\fBctf_float_nowrite\fR(\fIfloat_type\fR, \fIfield_name\fR, \fIexpr\fR)
.fi
.if n \{\
.RE
.\}
.sp
Null\-terminated string:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_string\fR(\fIfield_name\fR, \fIexpr\fR)
\fBctf_string_nowrite\fR(\fIfield_name\fR, \fIexpr\fR)
.fi
.if n \{\
.RE
.\}
.sp
Statically\-sized array of integers (\fB_hex\fR versions displayed in hexadecimal, \fB_network\fR versions in network byte order):
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_array\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
\fBctf_array_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
\fBctf_array_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
\fBctf_array_nowrite_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
\fBctf_array_network\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
\fBctf_array_network_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
\fBctf_array_network_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
\fBctf_array_network_nowrite_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
.fi
.if n \{\
.RE
.\}
.sp
Statically\-sized array, printed as text; no need to be null\-terminated:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_array_text\fR(char, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
\fBctf_array_text_nowrite\fR(char, \fIfield_name\fR, \fIexpr\fR, \fIcount\fR)
.fi
.if n \{\
.RE
.\}
.sp
Dynamically\-sized array of integers (\fB_hex\fR versions displayed in hexadecimal, \fB_network\fR versions in network byte order):
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_sequence\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR, \fIlen_expr\fR)
\fBctf_sequence_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR, \fIlen_expr\fR)
\fBctf_sequence_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR, \fIlen_expr\fR)
\fBctf_sequence_nowrite_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                         \fIlen_expr\fR)
\fBctf_sequence_network\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR, \fIlen_expr\fR)
\fBctf_sequence_network_nowrite\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                             \fIlen_expr\fR)
\fBctf_sequence_network_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR,
                         \fIlen_expr\fR)
\fBctf_sequence_network_nowrite_hex\fR(\fIint_type\fR, \fIfield_name\fR, \fIexpr\fR,
                                 \fIlen_type\fR, \fIlen_expr\fR)
.fi
.if n \{\
.RE
.\}
.sp
Dynamically\-sized array, displayed as text; no need to be null\-terminated:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_sequence_text\fR(char, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR, \fIlen_expr\fR)
\fBctf_sequence_text_nowrite\fR(char, \fIfield_name\fR, \fIexpr\fR, \fIlen_type\fR, \fIlen_expr\fR)
.fi
.if n \{\
.RE
.\}
.sp
Enumeration\&. The enumeration field must be defined before using this macro with the \fBTRACEPOINT_ENUM()\fR macro\&. See the \fITRACEPOINT_ENUM() usage\fR section for more information\&.
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_enum\fR(\fIprov_name\fR, \fIenum_name\fR, \fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
\fBctf_enum_nowrite\fR(\fIprov_name\fR, \fIenum_name\fR, \fIint_type\fR, \fIfield_name\fR, \fIexpr\fR)
.fi
.if n \{\
.RE
.\}
.sp
The parameters are:
.PP
\fIcount\fR
.RS 4
Number of elements in array/sequence\&. This must be known at compile time\&.
.RE
.PP
\fIenum_name\fR
.RS 4
Name of an enumeration field previously defined with the
\fBTRACEPOINT_ENUM()\fR
macro\&. See the
\fITRACEPOINT_ENUM() usage\fR
section for more information\&.
.RE
.PP
\fIexpr\fR
.RS 4
C expression resulting in the field\(cqs value\&. This expression can use one or more arguments passed to the tracepoint\&. The arguments of a given tracepoint are defined in the
\fBTP_ARGS()\fR
macro (see the
\fICreating a tracepoint provider\fR
section above)\&.
.RE
.PP
\fIfield_name\fR
.RS 4
Event field name (C identifier syntax, NOT a literal string)\&.
.RE
.PP
\fIfloat_type\fR
.RS 4
Float C type (\fBfloat\fR
or
\fBdouble\fR)\&. The size of this type determines the size of the floating point number field\&.
.RE
.PP
\fIint_type\fR
.RS 4
Integer C type\&. The size of this type determines the size of the integer/enumeration field\&.
.RE
.PP
\fIlen_expr\fR
.RS 4
C expression resulting in the sequence\(cqs length\&. This expression can use one or more arguments passed to the tracepoint\&.
.RE
.PP
\fIlen_type\fR
.RS 4
Unsigned integer C type of sequence\(cqs length\&.
.RE
.PP
\fIprov_name\fR
.RS 4
Tracepoint provider name\&. This must be the same as the tracepoint provider name used in a previous field definition\&.
.RE
.sp
The \fB_nowrite\fR versions omit themselves from the recorded trace, but are otherwise identical\&. Their primary purpose is to make some of the event context available to the event filters without having to commit the data to sub\-buffers\&. See \fBlttng-enable-event\fR(1) to learn more about dynamic event filtering\&.
.sp
See the \fIEXAMPLE\fR section below for a complete example\&.
.SS "TRACEPOINT_ENUM() usage"
.sp
An enumeration field is a list of mappings between an integers, or a range of integers, and strings (sometimes called \fIlabels\fR or \fIenumerators\fR)\&. Enumeration fields can be used to have a more compact trace when the possible values for a field are limited\&.
.sp
An enumeration field is defined with the \fBTRACEPOINT_ENUM()\fR macro:
.sp
.if n \{\
.RS 4
.\}
.nf
TRACEPOINT_ENUM(
    /* Tracepoint provider name */
    my_provider,

    /* Enumeration name (unique in the whole tracepoint provider) */
    my_enum,

    /* Enumeration mappings */
    TP_ENUM_VALUES(
        \&.\&.\&.
    )
)
.fi
.if n \{\
.RE
.\}
.sp
\fBTP_ENUM_VALUES()\fR contains a list of enumeration mappings, NOT separated by commas\&. Two macros can be used in the \fBTP_ENUM_VALUES()\fR: \fBctf_enum_value()\fR and \fBctf_enum_range()\fR\&.
.sp
\fBctf_enum_value()\fR is a single value mapping:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_enum_value\fR(\fIlabel\fR, \fIvalue\fR)
.fi
.if n \{\
.RE
.\}
.sp
This macro maps the given \fIlabel\fR string to the value \fIvalue\fR\&.
.sp
\fBctf_enum_range()\fR is a range mapping:
.sp
.if n \{\
.RS 4
.\}
.nf
\fBctf_enum_range\fR(\fIlabel\fR, \fIstart\fR, \fIend\fR)
.fi
.if n \{\
.RE
.\}
.sp
This macro maps the given \fIlabel\fR string to the range of integers from \fIstart\fR to \fIend\fR, inclusively\&. Range mappings may overlap, but the behaviour is implementation\-defined: each trace reader handles overlapping ranges as it wishes\&.
.sp
See the \fIEXAMPLE\fR section below for a complete example\&.
.SS "TRACEPOINT_EVENT_CLASS() usage"
.sp
A \fBtracepoint class\fR is a class of tracepoints sharing the same field types and names\&. A tracepoint instance is one instance of such a declared tracepoint class, with its own event name\&.
.sp
LTTng\-UST creates one event serialization function per tracepoint class\&. Using \fBTRACEPOINT_EVENT()\fR creates one tracepoint class per tracepoint definition, whereas using \fBTRACEPOINT_EVENT_CLASS()\fR and \fBTRACEPOINT_EVENT_INSTANCE()\fR creates one tracepoint class, and one or more tracepoint instances of this class\&. In other words, many tracepoints can reuse the same serialization code\&. Reusing the same code, when possible, can reduce cache pollution, thus improve performance\&.
.sp
The \fBTRACEPOINT_EVENT_CLASS()\fR macro accepts the same parameters as the \fBTRACEPOINT_EVENT()\fR macro, except that instead of an event name, its second parameter is the \fItracepoint class name\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
TRACEPOINT_EVENT_CLASS(
    /* Tracepoint provider name */
    my_provider,

    /* Tracepoint class name */
    my_tracepoint_class,

    /* List of tracepoint arguments (input) */
    TP_ARGS(
        \&.\&.\&.
    ),

    /* List of fields of eventual event (output) */
    TP_FIELDS(
        \&.\&.\&.
    )
)
.fi
.if n \{\
.RE
.\}
.sp
Once the tracepoint class is defined, you can create as many tracepoint instances as needed:
.sp
.if n \{\
.RS 4
.\}
.nf
TRACEPOINT_EVENT_INSTANCE(
    /* Tracepoint provider name */
    my_provider,

    /* Tracepoint class name */
    my_tracepoint_class,

    /* Tracepoint/event name */
    my_tracepoint,

    /* List of tracepoint arguments (input) */
    TP_ARGS(
        \&.\&.\&.
    )
)
.fi
.if n \{\
.RE
.\}
.sp
As you can see, the \fBTRACEPOINT_EVENT_INSTANCE()\fR does not contain the \fBTP_FIELDS()\fR macro, because they are defined at the \fBTRACEPOINT_EVENT_CLASS()\fR level\&.
.sp
See the \fIEXAMPLE\fR section below for a complete example\&.
.SS "TRACEPOINT_LOGLEVEL() usage"
.sp
Optionally, a \fBlog level\fR can be assigned to a defined tracepoint\&. Assigning different levels of severity to tracepoints can be useful: when controlling tracing sessions, you can choose to only enable events falling into a specific log level range using the \fB--loglevel\fR and \fB--loglevel-only\fR options of the \fBlttng-enable-event\fR(1) command\&.
.sp
Log levels are assigned to tracepoints that are already defined using the \fBTRACEPOINT_LOGLEVEL()\fR macro\&. The latter must be used after having used \fBTRACEPOINT_EVENT()\fR or \fBTRACEPOINT_EVENT_INSTANCE()\fR for a given tracepoint\&. The \fBTRACEPOINT_LOGLEVEL()\fR macro is used as follows:
.sp
.if n \{\
.RS 4
.\}
.nf
TRACEPOINT_LOGLEVEL(
    /* Tracepoint provider name */
    my_provider,

    /* Tracepoint/event name */
    my_tracepoint,

    /* Log level */
    TRACE_INFO
)
.fi
.if n \{\
.RE
.\}
.sp
The available log level definitions are:
.PP
\fBTRACE_EMERG\fR
.RS 4
System is unusable\&.
.RE
.PP
\fBTRACE_ALERT\fR
.RS 4
Action must be taken immediately\&.
.RE
.PP
\fBTRACE_CRIT\fR
.RS 4
Critical conditions\&.
.RE
.PP
\fBTRACE_ERR\fR
.RS 4
Error conditions\&.
.RE
.PP
\fBTRACE_WARNING\fR
.RS 4
Warning conditions\&.
.RE
.PP
\fBTRACE_NOTICE\fR
.RS 4
Normal, but significant, condition\&.
.RE
.PP
\fBTRACE_INFO\fR
.RS 4
Informational message\&.
.RE
.PP
\fBTRACE_DEBUG_SYSTEM\fR
.RS 4
Debug information with system\-level scope (set of programs)\&.
.RE
.PP
\fBTRACE_DEBUG_PROGRAM\fR
.RS 4
Debug information with program\-level scope (set of processes)\&.
.RE
.PP
\fBTRACE_DEBUG_PROCESS\fR
.RS 4
Debug information with process\-level scope (set of modules)\&.
.RE
.PP
\fBTRACE_DEBUG_MODULE\fR
.RS 4
Debug information with module (executable/library) scope (set of units)\&.
.RE
.PP
\fBTRACE_DEBUG_UNIT\fR
.RS 4
Debug information with compilation unit scope (set of functions)\&.
.RE
.PP
\fBTRACE_DEBUG_FUNCTION\fR
.RS 4
Debug information with function\-level scope\&.
.RE
.PP
\fBTRACE_DEBUG_LINE\fR
.RS 4
Debug information with line\-level scope (default log level)\&.
.RE
.PP
\fBTRACE_DEBUG\fR
.RS 4
Debug\-level message\&.
.RE
.sp
See the \fIEXAMPLE\fR section below for a complete example\&.
.SS "Instrumenting your application"
.sp
Once the tracepoint provider is created (see the \fICreating a tracepoint provider\fR section above), you can instrument your application with the defined tracepoints thanks to the \fBtracepoint()\fR macro:
.sp
.if n \{\
.RS 4
.\}
.nf
#define \fBtracepoint\fR(\fIprov_name\fR, \fIt_name\fR, \&...)
.fi
.if n \{\
.RE
.\}
.sp
With:
.PP
\fIprov_name\fR
.RS 4
Tracepoint provider name\&.
.RE
.PP
\fIt_name\fR
.RS 4
Tracepoint/event name\&.
.RE
.PP
\fB...\fR
.RS 4
Tracepoint arguments, if any\&.
.RE
.sp
Make sure to include the tracepoint provider header file anywhere you use \fBtracepoint()\fR for this provider\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Even though LTTng\-UST supports \fBtracepoint()\fR call site duplicates having the same provider and tracepoint names, it is recommended to use a provider/tracepoint name pair only once within the application source code to help map events back to their call sites when analyzing the trace\&.
.sp .5v
.RE
.sp
Sometimes, arguments to the tracepoint are expensive to compute (take call stack, for example)\&. To avoid the computation when the tracepoint is disabled, you can use the \fBtracepoint_enabled()\fR and \fBdo_tracepoint()\fR macros:
.sp
.if n \{\
.RS 4
.\}
.nf
#define \fBtracepoint_enabled\fR(\fIprov_name\fR, \fIt_name\fR)
#define \fBdo_tracepoint\fR(\fIprov_name\fR, \fIt_name\fR, \&...)
.fi
.if n \{\
.RE
.\}
.sp
\fBtracepoint_enabled()\fR returns a non\-zero value if the tracepoint named \fIt_name\fR from the provider named \fIprov_name\fR is enabled at run time\&.
.sp
\fBdo_tracepoint()\fR is like \fBtracepoint()\fR, except that it doesn\(cqt check if the tracepoint is enabled\&. Using \fBtracepoint()\fR with \fBtracepoint_enabled()\fR is dangerous since \fBtracepoint()\fR also contains the \fBtracepoint_enabled()\fR check, thus a race condition is possible in this situation:
.sp
.if n \{\
.RS 4
.\}
.nf
if (tracepoint_enabled(my_provider, my_tracepoint)) {
    stuff = prepare_stuff();
}

tracepoint(my_provider, my_tracepoint, stuff);
.fi
.if n \{\
.RE
.\}
.sp
If the tracepoint is enabled after the condition, then \fBstuff\fR is not prepared: the emitted event will either contain wrong data, or the whole application could crash (segmentation fault, for example)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Neither \fBtracepoint_enabled()\fR nor \fBdo_tracepoint()\fR have a \fBSTAP_PROBEV()\fR call, so if you need it, you should emit this call yourself\&.
.sp .5v
.RE
.SS "Statically linking the tracepoint provider"
.sp
With the static linking method, compiled tracepoint providers are copied into the target application\&.
.sp
Define \fBTRACEPOINT_DEFINE\fR definition below the \fBTRACEPOINT_CREATE_PROBES\fR definition in the tracepoint provider source:
.sp
.if n \{\
.RS 4
.\}
.nf
#define TRACEPOINT_CREATE_PROBES
#define TRACEPOINT_DEFINE

#include "tp\&.h"
.fi
.if n \{\
.RE
.\}
.sp
Create the tracepoint provider object file:
.sp
.if n \{\
.RS 4
.\}
.nf
$ cc \-c \-I\&. tp\&.c
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Although an application instrumented with LTTng\-UST tracepoints can be compiled with a C++ compiler, tracepoint probes should be compiled with a C compiler\&.
.sp .5v
.RE
.sp
At this point, you \fIcan\fR archive this tracepoint provider object file, possibly with other object files of your application or with other tracepoint provider object files, as a static library:
.sp
.if n \{\
.RS 4
.\}
.nf
$ ar rc tp\&.a tp\&.o
.fi
.if n \{\
.RE
.\}
.sp
Using a static library does have the advantage of centralising the tracepoint providers objects so they can be shared between multiple applications\&. This way, when the tracepoint provider is modified, the source code changes don\(cqt have to be patched into each application\(cqs source code tree\&. The applications need to be relinked after each change, but need not to be otherwise recompiled (unless the tracepoint provider\(cqs API changes)\&.
.sp
Then, link your application with this object file (or with the static library containing it) and with \fBliblttng-ust\fR and \fBlibdl\fR (\fBlibc\fR on a BSD system):
.sp
.if n \{\
.RS 4
.\}
.nf
$ cc \-o app tp\&.o app\&.o \-llttng\-ust \-ldl
.fi
.if n \{\
.RE
.\}
.SS "Dynamically loading the tracepoint provider"
.sp
The second approach to package the tracepoint provider is to use the dynamic loader: the library and its member functions are explicitly sought, loaded at run time\&.
.sp
In this scenario, the tracepoint provider is compiled as a shared object\&.
.sp
The process to create the tracepoint provider shared object is pretty much the same as the \fIstatic linking method\fR, except that:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Since the tracepoint provider is not part of the application,
\fBTRACEPOINT_DEFINE\fR
must be defined, for each tracepoint provider, in exactly one source file of the
\fIapplication\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBTRACEPOINT_PROBE_DYNAMIC_LINKAGE\fR
must be defined next to
\fBTRACEPOINT_DEFINE\fR
.RE
.sp
Regarding \fBTRACEPOINT_DEFINE\fR and \fBTRACEPOINT_PROBE_DYNAMIC_LINKAGE\fR, the recommended practice is to use a separate C source file in your application to define them, then include the tracepoint provider header files afterwards\&. For example, as \fBtp-define.c\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
#define TRACEPOINT_DEFINE
#define TRACEPOINT_PROBE_DYNAMIC_LINKAGE

#include "tp\&.h"
.fi
.if n \{\
.RE
.\}
.sp
The tracepoint provider object file used to create the shared library is built like it is using the static linking method, but with the \fB-fpic\fR option:
.sp
.if n \{\
.RS 4
.\}
.nf
$ cc \-c \-fpic \-I\&. tp\&.c
.fi
.if n \{\
.RE
.\}
.sp
It is then linked as a shared library like this:
.sp
.if n \{\
.RS 4
.\}
.nf
$ cc \-shared \-Wl,\-\-no\-as\-needed \-o tp\&.so tp\&.o \-llttng\-ust
.fi
.if n \{\
.RE
.\}
.sp
This tracepoint provider shared object isn\(cqt linked with the user application: it must be loaded manually\&. This is why the application is built with no mention of this tracepoint provider, but still needs libdl:
.sp
.if n \{\
.RS 4
.\}
.nf
$ cc \-o app app\&.o tp\-define\&.o \-ldl
.fi
.if n \{\
.RE
.\}
.sp
There are two ways to dynamically load the tracepoint provider shared object:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Load it manually from the application using
\fBdlopen\fR(3)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Make the dynamic loader load it with the
\fBLD_PRELOAD\fR
environment variable (see
\fBld.so\fR(8))
.RE
.sp
If the application does not dynamically load the tracepoint provider shared object using one of the methods above, tracing is disabled for this application, and the events are not listed in the output of \fBlttng-list\fR(1)\&.
.sp
Note that it is not safe to use \fBdlclose\fR(3) on a tracepoint provider shared object that is being actively used for tracing, due to a lack of reference counting from LTTng\-UST to the shared object\&.
.sp
For example, statically linking a tracepoint provider to a shared object which is to be dynamically loaded by an application (a plugin, for example) is not safe: the shared object, which contains the tracepoint provider, could be dynamically closed (\fBdlclose\fR(3)) at any time by the application\&.
.sp
To instrument a shared object, either:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Statically link the tracepoint provider to the application, or
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Build the tracepoint provider as a shared object (following the procedure shown in this section), and preload it when tracing is needed using the
\fBLD_PRELOAD\fR
environment variable\&.
.RE
.SS "Using LTTng\-UST with daemons"
.sp
Some extra care is needed when using \fBliblttng-ust\fR with daemon applications that call \fBfork\fR(2), \fBclone\fR(2), or BSD\(cqs \fBrfork\fR(2) without a following \fBexec\fR(3) family system call\&. The library \fBliblttng-ust-fork.so\fR needs to be preloaded before starting the application with the \fBLD_PRELOAD\fR environment variable (see \fBld.so\fR(8))\&.
.sp
To use \fBliblttng-ust\fR with a daemon application which closes file descriptors that were not opened by it, preload the \fBliblttng-ust-fd.so\fR library before you start the application\&. Typical use cases include daemons closing all file descriptors after \fBfork\fR(2), and buggy applications doing \(lqdouble\-closes\(rq\&.
.SS "Context information"
.sp
Context information can be prepended by the LTTng\-UST tracer before each event, or before specific events\&.
.sp
Context fields can be added to specific channels using \fBlttng-add-context\fR(1)\&.
.sp
The following context fields are supported by LTTng\-UST:
.PP
\fBcpu_id\fR
.RS 4
CPU ID\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This context field is always enabled, and it cannot be added with
\fBlttng-add-context\fR(1)\&. Its main purpose is to be used for dynamic event filtering\&. See
\fBlttng-enable-event\fR(1)
for more information about event filtering\&.
.sp .5v
.RE
.RE
.PP
\fBip\fR
.RS 4
Instruction pointer: enables recording the exact address from which an event was emitted\&. This context field can be used to reverse\-lookup the source location that caused the event to be emitted\&.
.RE
.PP
\fBperf:thread:COUNTER\fR
.RS 4
perf counter named
\fICOUNTER\fR\&. Use
\fBlttng add-context --list\fR
to list the available perf counters\&.
.sp
Only available on IA\-32 and x86\-64 architectures\&.
.RE
.PP
\fBperf:thread:raw:rN:NAME\fR
.RS 4
perf counter with raw ID
\fIN\fR
and custom name
\fINAME\fR\&. See
\fBlttng-add-context\fR(1)
for more details\&.
.RE
.PP
\fBpthread_id\fR
.RS 4
POSIX thread identifier\&. Can be used on architectures where
\fBpthread_t\fR
maps nicely to an
\fBunsigned long\fR
type\&.
.RE
.PP
\fBprocname\fR
.RS 4
Thread name, as set by
\fBexec\fR(3)
or
\fBprctl\fR(2)\&. It is recommended that programs set their thread name with
\fBprctl\fR(2)
before hitting the first tracepoint for that thread\&.
.RE
.PP
\fBvpid\fR
.RS 4
Virtual process ID: process ID as seen from the point of view of the process namespace\&.
.RE
.PP
\fBvtid\fR
.RS 4
Virtual thread ID: thread ID as seen from the point of view of the process namespace\&.
.RE
.SS "LTTng\-UST state dump"
.sp
If an application that uses \fBliblttng-ust\fR becomes part of a tracing session, information about its currently loaded shared objects, their build IDs, and their debug link information are emitted as events by the tracer\&.
.sp
The following LTTng\-UST state dump events exist and must be enabled to record application state dumps\&. Note that, during the state dump phase, LTTng\-UST can also emit \fIshared library load/unload\fR events (see \fIShared library load/unload tracking\fR below)\&.
.PP
\fBlttng_ust_statedump:start\fR
.RS 4
Emitted when the state dump begins\&.
.sp
This event has no fields\&.
.RE
.PP
\fBlttng_ust_statedump:end\fR
.RS 4
Emitted when the state dump ends\&. Once this event is emitted, it is guaranteed that, for a given process, the state dump is complete\&.
.sp
This event has no fields\&.
.RE
.PP
\fBlttng_ust_statedump:bin_info\fR
.RS 4
Emitted when information about a currently loaded executable or shared object is found\&.
.sp
Fields:
.TS
allbox tab(:);
ltB ltB.
T{
Field name
T}:T{
Description
T}
.T&
lt lt
lt lt
lt lt
lt lt
lt lt
lt lt.
T{
\fBbaddr\fR
T}:T{
Base address of loaded executable\&.
T}
T{
\fBmemsz\fR
T}:T{
Size of loaded executable in memory\&.
T}
T{
\fBpath\fR
T}:T{
Path to loaded executable file\&.
T}
T{
\fBis_pic\fR
T}:T{
Whether or not the executable is position\-independent code\&.
T}
T{
\fBhas_build_id\fR
T}:T{
Whether or not the executable has a build ID\&. If this field is 1, you can expect that an
\fBlttng_ust_statedump:build_id\fR
event record follows this one (not necessarily immediately after)\&.
T}
T{
\fBhas_debug_link\fR
T}:T{
Whether or not the executable has debug link information\&. If this field is 1, you can expect that an
\fBlttng_ust_statedump:debug_link\fR
event record follows this one (not necessarily immediately after)\&.
T}
.TE
.sp 1
.RE
.PP
\fBlttng_ust_statedump:build_id\fR
.RS 4
Emitted when a build ID is found in a currently loaded shared library\&. See
Debugging Information in Separate Files <https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html>
for more information about build IDs\&.
.sp
Fields:
.TS
allbox tab(:);
ltB ltB.
T{
Field name
T}:T{
Description
T}
.T&
lt lt
lt lt.
T{
\fBbaddr\fR
T}:T{
Base address of loaded library\&.
T}
T{
\fBbuild_id\fR
T}:T{
Build ID\&.
T}
.TE
.sp 1
.RE
.PP
\fBlttng_ust_statedump:debug_link\fR
.RS 4
Emitted when debug link information is found in a currently loaded shared library\&. See
Debugging Information in Separate Files <https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html>
for more information about debug links\&.
.sp
Fields:
.TS
allbox tab(:);
ltB ltB.
T{
Field name
T}:T{
Description
T}
.T&
lt lt
lt lt
lt lt.
T{
\fBbaddr\fR
T}:T{
Base address of loaded library\&.
T}
T{
\fBcrc\fR
T}:T{
Debug link file\(cqs CRC\&.
T}
T{
\fBfilename\fR
T}:T{
Debug link file name\&.
T}
.TE
.sp 1
.RE
.SS "Shared library load/unload tracking"
.sp
The \fILTTng-UST state dump\fR and the LTTng\-UST helper library to instrument the dynamic linker (see \fBliblttng-ust-dl\fR(3)) can emit \fBshared library load/unload tracking\fR events\&.
.sp
The following shared library load/unload tracking events exist and must be enabled to track the loading and unloading of shared libraries:
.PP
\fBlttng_ust_lib:load\fR
.RS 4
Emitted when a shared library (shared object) is loaded\&.
.sp
Fields:
.TS
allbox tab(:);
ltB ltB.
T{
Field name
T}:T{
Description
T}
.T&
lt lt
lt lt
lt lt
lt lt
lt lt.
T{
\fBbaddr\fR
T}:T{
Base address of loaded library\&.
T}
T{
\fBmemsz\fR
T}:T{
Size of loaded library in memory\&.
T}
T{
\fBpath\fR
T}:T{
Path to loaded library file\&.
T}
T{
\fBhas_build_id\fR
T}:T{
Whether or not the library has a build ID\&. If this field is 1, you can expect that an
\fBlttng_ust_lib:build_id\fR
event record follows this one (not necessarily immediately after)\&.
T}
T{
\fBhas_debug_link\fR
T}:T{
Whether or not the library has debug link information\&. If this field is 1, you can expect that an
\fBlttng_ust_lib:debug_link\fR
event record follows this one (not necessarily immediately after)\&.
T}
.TE
.sp 1
.RE
.PP
\fBlttng_ust_lib:unload\fR
.RS 4
Emitted when a shared library (shared object) is unloaded\&.
.sp
Fields:
.TS
allbox tab(:);
ltB ltB.
T{
Field name
T}:T{
Description
T}
.T&
lt lt.
T{
\fBbaddr\fR
T}:T{
Base address of unloaded library\&.
T}
.TE
.sp 1
.RE
.PP
\fBlttng_ust_lib:build_id\fR
.RS 4
Emitted when a build ID is found in a loaded shared library (shared object)\&. See
Debugging Information in Separate Files <https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html>
for more information about build IDs\&.
.sp
Fields:
.TS
allbox tab(:);
ltB ltB.
T{
Field name
T}:T{
Description
T}
.T&
lt lt
lt lt.
T{
\fBbaddr\fR
T}:T{
Base address of loaded library\&.
T}
T{
\fBbuild_id\fR
T}:T{
Build ID\&.
T}
.TE
.sp 1
.RE
.PP
\fBlttng_ust_lib:debug_link\fR
.RS 4
Emitted when debug link information is found in a loaded shared library (shared object)\&. See
Debugging Information in Separate Files <https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html>
for more information about debug links\&.
.sp
Fields:
.TS
allbox tab(:);
ltB ltB.
T{
Field name
T}:T{
Description
T}
.T&
lt lt
lt lt
lt lt.
T{
\fBbaddr\fR
T}:T{
Base address of loaded library\&.
T}
T{
\fBcrc\fR
T}:T{
Debug link file\(cqs CRC\&.
T}
T{
\fBfilename\fR
T}:T{
Debug link file name\&.
T}
.TE
.sp 1
.RE
.SS "Detect if LTTng\-UST is loaded"
.sp
To detect if \fBliblttng-ust\fR is loaded from an application:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Define the
\fBlttng_ust_loaded\fR
weak symbol globally:
.sp
.if n \{\
.RS 4
.\}
.nf
int lttng_ust_loaded __attribute__((weak));
.fi
.if n \{\
.RE
.\}
.sp
This weak symbol is set by the constructor of
\fBliblttng-ust\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Test
\fBlttng_ust_loaded\fR
where needed:
.sp
.if n \{\
.RS 4
.\}
.nf
/* \&.\&.\&. */

if (lttng_ust_loaded) {
    /* LTTng\-UST is loaded */
} else {
    /* LTTng\-UST is NOT loaded */
}

/* \&.\&.\&. */
.fi
.if n \{\
.RE
.\}
.RE
.SH "EXAMPLE"
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
A few examples are available in the \fBdoc/examples\fR <https://github.com/lttng/lttng-ust/tree/master/doc/examples> directory of LTTng\-UST\(cqs source tree\&.
.sp .5v
.RE
.sp
This example shows all the features documented in the previous sections\&. The \fIstatic linking\fR method is chosen here to link the application with the tracepoint provider\&.
.sp
You can compile the source files and link them together statically like this:
.sp
.if n \{\
.RS 4
.\}
.nf
$ cc \-c \-I\&. tp\&.c
$ cc \-c app\&.c
$ cc \-o app tp\&.o app\&.o \-llttng\-ust \-ldl
.fi
.if n \{\
.RE
.\}
.sp
Using the \fBlttng\fR(1) tool, create an LTTng tracing session, enable all the events of this tracepoint provider, and start tracing:
.sp
.if n \{\
.RS 4
.\}
.nf
$ lttng create my\-session
$ lttng enable\-event \-\-userspace \*(Aqmy_provider:*\*(Aq
$ lttng start
.fi
.if n \{\
.RE
.\}
.sp
You may also enable specific events:
.sp
.if n \{\
.RS 4
.\}
.nf
$ lttng enable\-event \-\-userspace my_provider:big_event
$ lttng enable\-event \-\-userspace my_provider:event_instance2
.fi
.if n \{\
.RE
.\}
.sp
Run the application:
.sp
.if n \{\
.RS 4
.\}
.nf
$ \&./app some arguments
.fi
.if n \{\
.RE
.\}
.sp
Stop the current tracing session and inspect the recorded events:
.sp
.if n \{\
.RS 4
.\}
.nf
$ lttng stop
$ lttng view
.fi
.if n \{\
.RE
.\}
.SS "Tracepoint provider header file"
.sp
\fBtp.h\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
#undef TRACEPOINT_PROVIDER
#define TRACEPOINT_PROVIDER my_provider

#undef TRACEPOINT_INCLUDE
#define TRACEPOINT_INCLUDE "\&./tp\&.h"

#if !defined(_TP_H) || defined(TRACEPOINT_HEADER_MULTI_READ)
#define _TP_H

#include <lttng/tracepoint\&.h>
#include <stdio\&.h>

#include "app\&.h"

TRACEPOINT_EVENT(
    my_provider,
    simple_event,
    TP_ARGS(
        int, my_integer_arg,
        const char *, my_string_arg
    ),
    TP_FIELDS(
        ctf_string(argc, my_string_arg)
        ctf_integer(int, argv, my_integer_arg)
    )
)

TRACEPOINT_ENUM(
    my_provider,
    my_enum,
    TP_ENUM_VALUES(
        ctf_enum_value("ZERO", 0)
        ctf_enum_value("ONE", 1)
        ctf_enum_value("TWO", 2)
        ctf_enum_range("A RANGE", 52, 125)
        ctf_enum_value("ONE THOUSAND", 1000)
    )
)

TRACEPOINT_EVENT(
    my_provider,
    big_event,
    TP_ARGS(
        int, my_integer_arg,
        const char *, my_string_arg,
        FILE *, stream,
        double, flt_arg,
        int *, array_arg
    ),
    TP_FIELDS(
        ctf_integer(int, int_field1, my_integer_arg * 2)
        ctf_integer_hex(long int, stream_pos, ftell(stream))
        ctf_float(double, float_field, flt_arg)
        ctf_string(string_field, my_string_arg)
        ctf_array(int, array_field, array_arg, 7)
        ctf_array_text(char, array_text_field, array_arg, 5)
        ctf_sequence(int, seq_field, array_arg, int,
                     my_integer_arg / 10)
        ctf_sequence_text(char, seq_text_field, array_arg,
                          int, my_integer_arg / 5)
        ctf_enum(my_provider, my_enum, int,
                 enum_field, array_arg[1])
    )
)

TRACEPOINT_LOGLEVEL(my_provider, big_event, TRACE_WARNING)

TRACEPOINT_EVENT_CLASS(
    my_provider,
    my_tracepoint_class,
    TP_ARGS(
        int, my_integer_arg,
        struct app_struct *, app_struct_arg
    ),
    TP_FIELDS(
        ctf_integer(int, a, my_integer_arg)
        ctf_integer(unsigned long, b, app_struct_arg\->b)
        ctf_string(c, app_struct_arg\->c)
    )
)

TRACEPOINT_EVENT_INSTANCE(
    my_provider,
    my_tracepoint_class,
    event_instance1,
    TP_ARGS(
        int, my_integer_arg,
        struct app_struct *, app_struct_arg
    )
)

TRACEPOINT_EVENT_INSTANCE(
    my_provider,
    my_tracepoint_class,
    event_instance2,
    TP_ARGS(
        int, my_integer_arg,
        struct app_struct *, app_struct_arg
    )
)

TRACEPOINT_LOGLEVEL(my_provider, event_instance2, TRACE_INFO)

TRACEPOINT_EVENT_INSTANCE(
    my_provider,
    my_tracepoint_class,
    event_instance3,
    TP_ARGS(
        int, my_integer_arg,
        struct app_struct *, app_struct_arg
    )
)

#endif /* _TP_H */

#include <lttng/tracepoint\-event\&.h>
.fi
.if n \{\
.RE
.\}
.SS "Tracepoint provider source file"
.sp
\fBtp.c\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
#define TRACEPOINT_CREATE_PROBES
#define TRACEPOINT_DEFINE

#include "tp\&.h"
.fi
.if n \{\
.RE
.\}
.SS "Application header file"
.sp
\fBapp.h\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
#ifndef _APP_H
#define _APP_H

struct app_struct {
    unsigned long b;
    const char *c;
    double d;
};

#endif /* _APP_H */
.fi
.if n \{\
.RE
.\}
.SS "Application source file"
.sp
\fBapp.c\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
#include <stdlib\&.h>
#include <stdio\&.h>

#include "tp\&.h"
#include "app\&.h"

static int array_of_ints[] = {
    100, \-35, 1, 23, 14, \-6, 28, 1001, \-3000,
};

int main(int argc, char* argv[])
{
    FILE *stream;
    struct app_struct app_struct;

    tracepoint(my_provider, simple_event, argc, argv[0]);
    stream = fopen("/tmp/app\&.txt", "w");

    if (!stream) {
        fprintf(stderr,
                "Error: Cannot open /tmp/app\&.txt for writing\en");
        return EXIT_FAILURE;
    }

    if (fprintf(stream, "0123456789") != 10) {
        fclose(stream);
        fprintf(stderr, "Error: Cannot write to /tmp/app\&.txt\en");
        return EXIT_FAILURE;
    }

    tracepoint(my_provider, big_event, 35, "hello tracepoint",
               stream, \-3\&.14, array_of_ints);
    fclose(stream);
    app_struct\&.b = argc;
    app_struct\&.c = "[the string]";
    tracepoint(my_provider, event_instance1, 23, &app_struct);
    app_struct\&.b = argc * 5;
    app_struct\&.c = "[other string]";
    tracepoint(my_provider, event_instance2, 17, &app_struct);
    app_struct\&.b = 23;
    app_struct\&.c = "nothing";
    tracepoint(my_provider, event_instance3, \-52, &app_struct);

    return EXIT_SUCCESS;
}
.fi
.if n \{\
.RE
.\}
.SH "ENVIRONMENT VARIABLES"
.PP
\fBLTTNG_HOME\fR
.RS 4
Alternative user\(cqs home directory\&. This variable is useful when the user running the instrumented application has a non\-writable home directory\&.
.sp
Unix sockets used for the communication between
\fBliblttng-ust\fR
and the LTTng session and consumer daemons (part of the LTTng\-tools project) are located in a specific directory under
\fB$LTTNG_HOME\fR
(or
\fB$HOME\fR
if
\fB$LTTNG_HOME\fR
is not set)\&.
.RE
.PP
\fBLTTNG_UST_CLOCK_PLUGIN\fR
.RS 4
Path to the shared object which acts as the clock override plugin\&. An example of such a plugin can be found in the LTTng\-UST documentation under
\fBexamples/clock-override\fR <https://github.com/lttng/lttng-ust/tree/master/doc/examples/clock-override>\&.
.RE
.PP
\fBLTTNG_UST_DEBUG\fR
.RS 4
Activates
\fBliblttng-ust\fR\*(Aqs debug and error output if set to
\fB1\fR\&.
.RE
.PP
\fBLTTNG_UST_GETCPU_PLUGIN\fR
.RS 4
Path to the shared object which acts as the
\fBgetcpu()\fR
override plugin\&. An example of such a plugin can be found in the LTTng\-UST documentation under
\fBexamples/getcpu-override\fR <https://github.com/lttng/lttng-ust/tree/master/doc/examples/getcpu-override>\&.
.RE
.PP
\fBLTTNG_UST_REGISTER_TIMEOUT\fR
.RS 4
Waiting time for the
\fIregistration done\fR
session daemon command before proceeding to execute the main program (milliseconds)\&.
.sp
The value
\fB0\fR
means
\fIdo not wait\fR\&. The value
\fB-1\fR
means
\fIwait forever\fR\&. Setting this environment variable to
\fB0\fR
is recommended for applications with time constraints on the process startup time\&.
.sp
Default: 3000\&.
.RE
.PP
\fBLTTNG_UST_WITHOUT_BADDR_STATEDUMP\fR
.RS 4
Prevents
\fBliblttng-ust\fR
from performing a base address state dump (see the
\fILTTng-UST state dump\fR
section above) if set to
\fB1\fR\&.
.RE
.SH "BUGS"
.sp
If you encounter any issue or usability problem, please report it on the LTTng bug tracker <https://bugs.lttng.org/projects/lttng-ust>\&.
.SH "RESOURCES"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
LTTng project website <http://lttng.org>
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
LTTng documentation <http://lttng.org/docs>
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Git repositories <http://git.lttng.org>
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
GitHub organization <http://github.com/lttng>
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Continuous integration <http://ci.lttng.org/>
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Mailing list <http://lists.lttng.org>
for support and development:
\fBlttng-dev@lists.lttng.org\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
IRC channel <irc://irc.oftc.net/lttng>:
\fB#lttng\fR
on
\fBirc.oftc.net\fR
.RE
.SH "COPYRIGHTS"
.sp
This library is part of the LTTng\-UST project\&.
.sp
This library is distributed under the GNU Lesser General Public License, version 2\&.1 <http://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html>\&. See the \fBCOPYING\fR <https://github.com/lttng/lttng-ust/blob/master/COPYING> file for more details\&.
.SH "THANKS"
.sp
Thanks to Ericsson for funding this work, providing real\-life use cases, and testing\&.
.sp
Special thanks to Michel Dagenais and the DORSAL laboratory <http://www.dorsal.polymtl.ca/> at \('Ecole Polytechnique de Montr\('eal for the LTTng journey\&.
.SH "AUTHORS"
.sp
LTTng\-UST was originally written by Mathieu Desnoyers, with additional contributions from various other people\&. It is currently maintained by Mathieu Desnoyers <mailto:mathieu.desnoyers@efficios.com>\&.
.SH "SEE ALSO"
.sp
\fBtracef\fR(3), \fBtracelog\fR(3), \fBlttng-gen-tp\fR(1), \fBlttng-ust-dl\fR(3), \fBlttng-ust-cyg-profile\fR(3), \fBlttng\fR(1), \fBlttng-enable-event\fR(1), \fBlttng-list\fR(1), \fBlttng-add-context\fR(1), \fBbabeltrace\fR(1), \fBdlopen\fR(3), \fBld.so\fR(8)
